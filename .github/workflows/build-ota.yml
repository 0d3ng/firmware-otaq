name: ESP-IDF Build & Secure OTA (ECDSA)

on:
  pull_request:
    branches:
      - master
      - development
    types: [closed]

jobs:
  build-ota:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    environment: firmware env

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y zip curl

      - name: Install Python dependencies
        run: pip install cryptography

      - name: Setup ESP-IDF
        run: |
          git clone --depth 1 --branch v5.5.1 https://github.com/espressif/esp-idf.git $HOME/esp-idf
          cd $HOME/esp-idf
          ./install.sh esp32

      - name: Set firmware version info
        run: |
          GIT_HASH=$(git rev-parse --short HEAD)
          BUILD_DATE=$(date "+%Y%m%dT%H%M")
          BUILD_NUMBER=${GITHUB_RUN_NUMBER}
          FIRMWARE_VERSION="${GIT_HASH}-${BUILD_DATE}-build${BUILD_NUMBER}"
          echo "FIRMWARE_VERSION=${FIRMWARE_VERSION}" >> $GITHUB_ENV
          echo "Firmware version: ${FIRMWARE_VERSION}"

      - name: Build firmware
        run: |
          . $HOME/esp-idf/export.sh

          echo "=== Step 1: Show FREERTOS configs in sdkconfig ==="
          grep FREERTOS sdkconfig || echo "No FREERTOS config found"

          echo "=== Step 2: Clean build to ensure FreeRTOS rebuilds ==="
          idf.py fullclean

          echo "=== Step 3: Set target ==="
          idf.py set-target esp32

          echo "=== Step 4: Build firmware ==="
          idf.py build -D FIRMWARE_VERSION="${{ env.FIRMWARE_VERSION }}"

          echo "=== Step 5: Check sdkconfig.h after build ==="
          grep FREERTOS_USE_TRACE_FACILITY build/config/sdkconfig.h || echo "TRACE_FACILITY not found"
          grep FREERTOS_USE_STATS_FORMATTING_FUNCTIONS build/config/sdkconfig.h || echo "STATS_FUNCTIONS not found"

      - name: Upload build logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: esp-idf-build-logs
          path: build/log/

      - name: Create manifest.json & package using ECDSA
        id: sign_package
        env:
          ECDSA_PRIVATE_KEY_HEX: ${{ secrets.ECDSA_PRIVATE_KEY_HEX }}
          VERSION: ${{ env.FIRMWARE_VERSION }} # or any other versioning scheme
        run: |
          # measure entire step (python + zip)
          START=$(date +%s%N)

          # measure signing time inside Python and write it into manifest.json
          python3 - <<'EOF'
          import cryptography
          import json, hashlib, time
          from cryptography.hazmat.primitives import hashes
          from cryptography.hazmat.primitives.asymmetric import ec
          from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature
          import os
          print("cryptography version:", cryptography.__version__)

          fw_file = "build/firmware-otaq.bin"
          with open(fw_file, "rb") as f:
              data = f.read()
          digest = hashlib.sha256(data).digest()
          print(f"Firmware {fw_file} size={len(data)} sha256={digest.hex()}")

          # Load private key from GitHub Secrets (hex string)
          private_key_hex = os.environ.get("ECDSA_PRIVATE_KEY_HEX","").strip()
          print(f"Raw key repr: {repr(private_key_hex)}")
          print(f"Length after strip: {len(private_key_hex)}")

          if len(private_key_hex) != 64:
              raise ValueError("Invalid ECDSA private key length")

          private_key = ec.derive_private_key(int(private_key_hex, 16), ec.SECP256R1())

          # time the signing (hashing already done above)
          t0 = time.perf_counter()
          signature = private_key.sign(digest, ec.ECDSA(hashes.SHA256()))
          t1 = time.perf_counter()
          signing_ms = (t1 - t0) * 1000.0

          # Convert to raw r||s format for compatibility with updater
          r, s = decode_dss_signature(signature)
          signature_bytes = r.to_bytes(32, 'big') + s.to_bytes(32, 'big')
          signature_hex = signature_bytes.hex()

          metadata = {
              "version": os.environ.get("VERSION", "1.0.0"),
              "hash": digest.hex(),
              "signature": signature_hex
          }
          print(f"Manifest: {metadata}")
          with open("manifest.json", "w") as f:
              json.dump(metadata, f, indent=2)

          print(f"Signing elapsed_ms={signing_ms:.3f}")
          EOF

          zip -j firmware.zip build/firmware-otaq.bin manifest.json

          END=$(date +%s%N)
          ELAPSED_MS=$(( (END-START)/1000000 ))
          echo "step_elapsed_ms=$ELAPSED_MS"
          # export as step output for later steps if needed
          echo "step_elapsed_ms=$ELAPSED_MS" >> $GITHUB_OUTPUT

      - name: Upload package via API
        run: |
          STATUS=$(curl -s -o response.txt -w "%{http_code}" \
            -X POST "${{ secrets.API_URL }}/firmware/upload" \
            -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
            -F "file=@firmware.zip")

          echo "Response code: $STATUS"
          if [ "$STATUS" -ne 200 ]; then
            echo "❌ Upload failed with status $STATUS"
            cat response.txt
            exit 1
          fi
          echo "✅ Upload successful"
